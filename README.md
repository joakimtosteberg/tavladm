1. I eventor så har man en huvudtävling (i LOK:s fall var detta den nationella tävlingen) samt en styck närtävling för varje startgrupp. Närtävlingarna namnges lämpligen så att startintervallet finns med i namnet (och om det är över flera dagar även datumet) Huvudtävlingen och alla närtävlingar ska vara identiskt uppsatta med klasser, avgifter och stoppdatum. Huvudtävlingen tas sedan så långt att anmälan öppnas för att sedan omedelbart ändra status till att anmälan är pausad. Närtävlingarna öppnar man anmälan i som vanligt och när det blir fullt i en startgrupp så får man manuellt gå in och pausa anmälan

2. I OLA tar man sedan och skapar en ny tävling från eventor (vissa saker längre fram förutsätter att man använder en mysql databas, det går troligen även med den interna h2 databasen, men då får man själv anpassa vissa steg till detta. Om man vill ha liversultat och kör sin mysql databas under linux så behöver man se till att man har satt "lower_case_table_names = 1" i sin mysql konfiguration och har startat om mysql servern innan man skapar databasen ifrån OLA, annars kommer det blir problem med versalkänslighet för tabellnamn då liveresultatsklienten måste köras under windows) och väljer där sin huvudtävling och sätter därefter upp i OLA precis som om det hade varit en vanlig tävling

3. Ändra i config.json så att den matchar era tävlingar, man kan i den definiera flera huvudevent om man vill, och kommer då få en uppsättning filer per huvudevent. Subids är en lista med närtävlingar, för att det ska bli bra i listor så bör dessa specas så att den tidigaste startgruppen är först i listan och den senaste sist. Fältet key ska sättas till den egna klubbens API nyckel för eventor. startlist_replacements kan användas för att få namnet på startgrupper i listorna lite bättre, om inget anges kommer det fulla namnet på varje närtävling att användas, här kan man speca delsträngar i namnen som ska ersättas med annat när startlistan skapas, som man kan använda för att t.ex. ha kvar bara datum och intervall.

4. Efter att både ordinarie anmälningstid samt efteranmälningstid har gått ut (det går att göra det i två steg om man vill ha in saker direkt efter ordinarie anmälningssteg, men då behöver det göras vissa anpassningar till scripten för detta) så tar man sedan och kör fetch_registrations.py som kommer att skapa en XML fil med alla startande som sedan kan importeras till OLA. Efter importen till OLA måste man sedan manuellt köra "USE <name_of_database>; UPDATE Entries SET externalId=NULL;" i en mysql-prompt för att rensa bort ett extern id som man får med i importen som är kopplat till närtävlingarna och som kommer ge problem vid uppladdning till eventor sedan annars (och det verkar tyvärr inte som det gick att utelämna detta id i XML filen som man importerar)

5. Nu kan man dels ladda upp startlistor till eventor direkt från OLA som vanligt, dock kommer man inte att komma med någon information om startgrupper och så där, det kan dock ändå vara bra att göra denna uppladdning för att se så att allt fungerar som det ska. Därefter kan man använda generate_startlists.py för att skapa två stycken olika startlistor, en grupperad per klass med information om startgrupp på varje rad och en grupperad per startgrupp med information om klass på varje rad, dessa filer kan man sedan ladda upp till eventor som dokument för att få en lite mer användbar startlista för löparna. Listan grupperad per startgrupp är även användbar för starten.

6. Om tävlingen är uppdelad på flera dagar kräver det lite extra koll på kvar i skogen också, enklast är det om man har startstämpling för alla då man bara kan läsa ut startenheten i OLA för att alla löpare som har startat ska sättas till aktiverade (o.b.s. man kan inte använda "sätt ej aktiverade till ej start" förrutom efter sista dagen, har man inte startstämpling kan det istället krävas manuell genomgång av avprickningslistor från starten för att vara på den säkra sidan. Det finns även en bugg i OLA vid inläsning från startenhet som gör att nummer för SI5-pinnar blir fel, så efter att ha läst ut innehållet ur en startenhet, innan man stänger dialogen så bör man välja att skriva ut till en HTML fil. Därefter kan man ta och öppna filen i en webbläsare, markera allt och kopiera in det i en textfil och därefter köra startpunch_fix.py <filename> på textfilen, scriptet kommer då spotta ur sig bricknummret som OLA sett det, samma bricknummer men tolkat så som ett SI5 nummer ska tolkas samt tiden den stämplade i startenheten. Därefter får man manuellt söka upp de bricknummrena i OLA och ändra status om någon av dem är ej aktiverade fortfarande (om man vill kan man även sätta starttiden till det som stod i utläsningen för att få bättre koll i kvar i skogen listan)

Under anmälningstidens gång finns även ett hjälpscript check_registrations.py som kan vara användbart, det kommer lista antalet anmälda i varje närtävling inklusive en länk till administrationssidan för tävlingen, användbart för att håll koll på anmälningsläget så man vet när det är dags att pausa anmälan. När anmälan till en närtävling är pausad kommer antalet anmälda till den att visas med en parantes runt av scriptet.


Ett par saker som inte hanteras fullt ut eller kräver handpåläggning:

* Hyrbrickor: Eftersom startlistan skapas utifrån information från eventor kommer man inte få med nummer på hyrbrickor efter tilldelande i OLA här, då det inte är någon större mängd hyrbrickor så löstes detta igenom att vi förhand skrev in det i HTML filerna.
* Ändringar efter import till OLA: Liknande problem som för hyrbricksnummer, då listorna genereras utifrån eventor så får man inte med eventuella ändringar som görs i OLA så som klassbyte eller liknande som kommer efter man har gjort importen. Här får man antingen återigen manuellt redigera HTML-koden om man vill ha med den uppdaterade informationen i startlistorna, alternativt acceptera att startlistorna inte har med sådana ändringar.


En punkt att tänka på är också hanterandet av etappdatum/nolltid om man kör med startgrupper utspridda över flera dagar. Det som vi testat är att ha samma etappdatum inställt i OLA alla dagarna, effekten blir då att det ser ut som alla löpare har sprungit på samma dag, och än så länge har vi inte sett någon negativ effekt av detta. Det borde dock gå att varje ny dag ändra etappdatum till den nya dagens datum innan första löpare kommer och då få löpare på rätt dag, dock ej testat om detta faktiskt fungerar bra i praktiken eller om det medför några oväntade problem.